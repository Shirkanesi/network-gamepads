== Introduction ==

This is the first draft for the network gamepad binary protocol.

The binary protocol is splitted into messages. Every message begins
with a one message type byte (uint8_t). After this the data part of the
message is followed.

== Overview of message types ==
* HELLO                  = 0x01
* PASSWORD               = 0x02
* ABSINFO                = 0x03
* DEVICE                 = 0x04
* SETUP_END              = 0x05
* DATA                   = 0x10
* SUCCESS                = 0xF0
* VERSION_MISMATCH       = 0xF1
* INVALID_PASSWORD       = 0xF2
* INVALID_CLIENT_SLOT    = 0xF3
* INVALID_MESSAGE        = 0xF4
* PASSWORD_REQUIRED      = 0xF5
* SETUP_REQUIRED         = 0xF6
* CLIENT_SLOT_IN_USE     = 0xF7
* CLIENT_SLOTS_EXHAUSTED = 0xF8

== Messages ==

=== Hello ===

The HELLO message must be send only at the beginning of a connection.
Its data part contains only the version of the used protocol The version is
one byte long (uint8_t).
The current version is 0x01.

After the version byte follows a client slot byte. This byte is for selecting
a slot on the server. If the byte is 0x00 the server selects a slot for
client.

If the protocol version of the server mismatches the sended version the server
replies with the VERSION_MISMATCH reply.

If the HELLO message is not sended at the beginning of the connection the
server replies with INVALID_MESSAGE.

If the client slot is already in use the server response with
CLIENT_SLOT_IN_USE.

If everything is fine the server respond with SETUP_REQUIRED or when a
password is required PASSWORD_REQUIRED.

Example:

0x01 0x01 0x00
(Message type: HELLO; Version: 0x01; Client slot: next free)

=== PASSWORD ===

If the server requires a password it sends the PASSWORD_REQUIRED answer.
After that the client must respond with the PASSWORD message.

The message type byte is followed by a password length byte and then followed by
the password. Because of one byte (uint8_t) the maximal length of a password is
limited to 255 byte. The password encoding should be ascii but is not limited
to it.

Example:
0x02 0x04 0x48 0x45 0x4C 0x4F
(Message type byte, length of the password is 4 byte, followed by HELO)

If the password is incorrect the server responds with INVALID_PASSWORD and
closes the connection.

If the password is correct the server responds with SETUP_REQUIRED or with
SUCCESS if the client slot has already been set up. This is only the case if
the client sends a valid client id in the HELLO message.

=== DEVICE ===

After getting a SETUP_REQUIRED event from the server. The client should
respond with the DEVICE message. This message contains infos to create the
uinput device on the server.
It contains the following infos:
* length (uint8_t): length of the name. The name should not be longer than
                    UINPUT_MAX_NAME_SIZE (see linux/uinput.h)
* type (uint8_t): device type (see "Device types" for valid values)
* ids (struct input_id): This is a struct from linux/input.h with the vendor id,
                         product _id, bustype and version of the device.
* name: a char array with the name of the device.

The server sends no answer to this message. The server waits for the SETUP_END
message.

=== ABSINFO ===

This message contains informations about an axis of an absolute device.
The client should send this message for every axis of the device.

struct {
	uint8_t msg_type     - must be ABSINFO
	uint8_t axis         - the corresponding axis (see linux/input.h or
	                       linux/input-event-codes.h) for valid axis
	struct input_absinfo - abs informations for the given axis (see
	                       linux/input.h)
}

The service will not respond until the SETUP_END message will be send.

=== SETUP_END ===

The message contains only the message type byte. It must be send to leave the
setup mode.

After the message send the server can answer with SUCCESS if everything is
fine.
